#ifndef FEM_STENCIL_H
#define FEM_STENCIL_H

#include <iostream>
#include <zjucad/matrix/matrix.h>
#include <hjlib/math/blas_lapack.h>
#include <zjucad/matrix/lapack.h>

#include "def.h"
#include "util.h"

namespace bigbang {

using mati_t=zjucad::matrix::matrix<size_t>;
using matd_t=zjucad::matrix::matrix<double>;

// All the basis functions follows the order
//
// N-1.. 2N-1 ..3N-1
//  : ... : ... :
//  : ... : ... :
//  2 .. N+2 .. :
//  1 .. N+1 .. :
//  0 ... N ... 2N
//
typedef void (*FEM_basis_func)(double*, const double*);
typedef void (*dis_FEM_basis_func)(double*, const double*, const matd_t &basisXYZ);

void full_quad_dis_shape_func_val(double *val, const double *eps, const matd_t &basisXY);
void full_quad_dis_shape_func_jac(double *jac, const double *eps, const matd_t &basisXY);
void full_hexs_dis_shape_func_val(double *val, const double *eps, const matd_t &basisXYZ);
void full_hexs_dis_shape_func_jac(double *jac, const double *eps, const matd_t &basisXYZ);

typedef double (*large_to_small_mapping)(const int k, const double *eps, double *xi);


///=========== QUAD STENCIL ==========///
/// The stencil here is refered to
/// integration unit in concept
/// quad_stencil is single quad as
/// integration domain
class quad_stencil
{
public:
  quad_stencil(const size_t curr_fid, const mati_t &curr_elem, const mati_t &adjc_elem,
               const std::vector<size_t> &faces, large_to_small_mapping l2s);
  const size_t curr_fid_;
  mati_t curr_elem_, adjc_elem_;          // central element and stencil element
  mati_t faces_;                          // face index in stencil
  large_to_small_mapping l2s_;            // map [-1,1]x[-1,1] to subdomain
  size_t curr_vert_num_, adjc_vert_num_;
  FEM_basis_func high_order_sf_jac_, rest_sf_jac_;

  virtual int set_full_discrete_shape_func(const matd_t &basisXY, const bool isotropic=true);
  dis_FEM_basis_func full_dis_high_sf_jac_;
  matd_t basisXY_;
  bool isotropic_;
  
  virtual int set_mtrs_and_qrs(const size_t per_face_to_many,
                               const mati_t &quad_h, const matd_t &nods_h,
                               const matd_t &lame_h);
  size_t qr_num_;
  matd_t qrs_, qrw_;
  matd_t lame_on_qrs_;

  virtual int set_def_grad_oper(const matd_t &adjc_nods);
  matd_t adjc_H_invDmH_; // matrix: [adjc_vert_num_, 2*#quadratures]
  matd_t adjc_df_op_;    // matrix: [2*adjc_vert_num_, 4*#quadratures]
  matd_t dets_;          // matrix: [#quadratures]
  matd_t adjc_rest_;
  matd_t DmHs_;          // matrix: [2 x 2#quadratures]
  
  virtual int query_local_frame(const matd_t &curr_nods, const size_t qrID, matd_t &R);
  virtual int get_coro_bases_df_val(const matd_t &curr_nods, const matd_t &R, const size_t qrID, matd_t &dF);
  virtual int get_coro_bases_df_jac(const matd_t &R, const size_t qrID, matd_t &G);
  matd_t dNude_, dNxde_;
};

class fem_quad9_stencil : public quad_stencil
{
public:
  /* non-overlapping second order elements */
  fem_quad9_stencil(const mati_t &quad9, const std::vector<size_t> &faces);
  int set_def_grad_oper(const matd_t &adjc_nods);
};

///========== HEX STENCIL ==========///
class hexs_stencil
{
public:
  hexs_stencil(const mati_t &adjc_elem, const std::vector<size_t> &faces);
  mati_t adjc_elem_;
  mati_t faces_;
  size_t adjc_vert_num_;
  FEM_basis_func fem_sf_jac_, rest_sf_jac_;

  virtual int set_full_discrete_shape_func(const matd_t &basisXYZ, const bool isotropic=true);
  dis_FEM_basis_func dis_fem_sf_jac_;
  matd_t basisXYZ_;
  bool isotropic_;
  
  virtual int set_mtrs_and_qrs(const size_t per_face_to_many,
                               const mati_t &hexs_h, const matd_t &nods_h,
                               const matd_t &lame_h);
  size_t qr_num_;
  matd_t qrs_, qrw_;
  matd_t lame_on_qrs_;

  virtual int set_def_grad_oper(const matd_t &adjc_nods);
  matd_t adjc_H_invDmH_; // matrix: [adjc_vert_num_, 3*#quadratures]
  matd_t adjc_df_op_;    // matrix: [3*adjc_vert_num_, 9*#quadratures]
  matd_t dets_;          // matrix: [#quadratures]
  matd_t adjc_rest_;
};

///========== STENCIL ENERGIES ==========///
class fem_stencil_energy_d2 : public Functional<double>
{
public:
  enum Material {
    LINEAR,
    STVK,
    COROTATED,
    NEOHOOKEAN
  };
  fem_stencil_energy_d2(const std::vector<std::shared_ptr<quad_stencil>> &elem_H,
                        const mati_t &quad_H, const matd_t &nods_H,
                        const Material type,
                        const mati_t &quad_h, const matd_t &nods_h, const matd_t &face_lame_h,
                        const double w);
  size_t Nx() const;
  int Val(const double *x, double *val) const;
  int Gra(const double *x, double *gra) const;
  int Hes(const double *x, std::vector<Eigen::Triplet<double>> *hes) const;
protected:
  const double w_;
  const size_t dim_;
  const std::vector<std::shared_ptr<quad_stencil>> &elem_;
  const Material type_;
};

class fem_stencil_energy_d3 : public Functional<double>
{
public:
  enum Material {
    LINEAR,
    STVK,
    COROTATED,
    NEOHOOKEAN
  };
  fem_stencil_energy_d3(const std::vector<std::shared_ptr<hexs_stencil>> &elem_H,
                        const mati_t &hexs_H, const matd_t &nods_H,
                        const Material type,
                        const mati_t &hexs_h, const matd_t &nods_h, const matd_t &face_lame_h,
                        const double w);
  size_t Nx() const;
  int Val(const double *x, double *val) const;
  int Gra(const double *x, double *gra) const;
  int Hes(const double *x, std::vector<Eigen::Triplet<double>> *hes) const;
protected:
  const double w_;
  const size_t dim_;
  const std::vector<std::shared_ptr<hexs_stencil>> &elem_;
  const Material type_;
};

std::shared_ptr<Functional<double>>
build_stencil_energy(const std::string &mtr, const std::vector<std::shared_ptr<quad_stencil>> &stencils,
                     const mati_t &quad_H, const matd_t &nods_H,
                     const mati_t &quad_h, const matd_t &nods_h, const matd_t &face_lame_h);

std::shared_ptr<Functional<double>>
build_stencil_energy(const std::string &mtr, const std::vector<std::shared_ptr<hexs_stencil>> &stencils,
                     const mati_t &hexs_H, const matd_t &nods_H,
                     const mati_t &hexs_h, const matd_t &nods_h, const matd_t &face_lame_h);

}

#endif
